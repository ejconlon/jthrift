%{
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Thrift parser.
 *
 * This parser is used on a thrift definition file.
 *
 */

class C {
/**
 * This global variable is used for automatic numbering of field indices etc.
 * when parsing the members of a struct. Field values are automatically
 * assigned starting from -1 and working their way down.
 */
static int y_field_val = -1;
static int g_arglist = 0;
static final int struct_is_struct = 0;
static final int struct_is_union = 1;

public static enum ParseMode {
    INCLUDES, PROGRAM
};
static ParseMode g_parse_mode = ParseMode.PROGRAM;

static int g_doctest_lineno;
static String g_doctext;

static void clear_doctext() {
  if (C.g_doctext != null) {
    pwarning(2, "Uncaptured doctext: "+C.g_doctext);
  }
  C.g_doctext = null;
}

/**
 * The master program parse tree. This is accessed from within the parser code
 * to build up the program elements.
 */
static TProgram g_program;

/**
 * Global types for the parser to be able to reference
 */

static TProgram g_type_void;
static TProgram g_type_string;
static TProgram g_type_binary;
static TProgram g_type_slist;
static TProgram g_type_bool;
static TProgram g_type_byte;
static TProgram g_type_i16;
static TProgram g_type_i32;
static TProgram g_type_i64;
static TProgram g_type_double;

static TScope g_scope;

static TScope g_parent_scope;

static String g_parent_prefix;

static bool g_allow_64bit_consts = true;

static void pdebug(String msg) {
    System.out.println("DEBUG: "+msg);
}

static void pwarning(int level, String msg) {
    System.out.println("WARN ("+level+"): "+msg);
}

}

%}

/**
 * This structure is used by the parser to hold the data types associated with
 * various parse nodes.
 */
%union {
  String         id;
  long           iconst;
  double         dconst;
  boolean        tbool;
  TDoc           tdoc;
  TType          ttype;
  TBaseType      tbase;
  TTypedef       ttypedef;
  TEnum          tenum;
  TEnumValue     tenumv;
  TConst         tconst;
  TConstValue    tconstv;
  TStruct        tstruct;
  TService       tservice;
  TFunction      tfunction;
  TField         tfield;
  String         dtext;
  TField.EReq    ereq;
  TAnnotation    tannot;
  TFieldId       tfieldid;
}

/**
 * Strings identifier
 */
%token<id>     tok_identifier
%token<id>     tok_literal
%token<dtext>  tok_doctext
%token<id>     tok_st_identifier

/**
 * Constant values
 */
%token<iconst> tok_int_constant
%token<dconst> tok_dub_constant

/**
 * Header keywords
 */
%token tok_include
%token tok_namespace
%token tok_cpp_namespace
%token tok_cpp_include
%token tok_cpp_type
%token tok_php_namespace
%token tok_py_module
%token tok_perl_package
%token tok_java_package
%token tok_xsd_all
%token tok_xsd_optional
%token tok_xsd_nillable
%token tok_xsd_namespace
%token tok_xsd_attrs
%token tok_ruby_namespace
%token tok_smalltalk_category
%token tok_smalltalk_prefix
%token tok_cocoa_prefix
%token tok_csharp_namespace
%token tok_delphi_namespace

/**
 * Base datatype keywords
 */
%token tok_void
%token tok_bool
%token tok_byte
%token tok_string
%token tok_binary
%token tok_slist
%token tok_senum
%token tok_i16
%token tok_i32
%token tok_i64
%token tok_double

/**
 * Complex type keywords
 */
%token tok_map
%token tok_list
%token tok_set

/**
 * Function modifiers
 */
%token tok_oneway

/**
 * Thrift language keywords
 */
%token tok_typedef
%token tok_struct
%token tok_xception
%token tok_throws
%token tok_extends
%token tok_service
%token tok_enum
%token tok_const
%token tok_required
%token tok_optional
%token tok_union

/**
 * Grammar nodes
 */

%type<ttype>     BaseType
%type<ttype>     SimpleBaseType
%type<ttype>     ContainerType
%type<ttype>     SimpleContainerType
%type<ttype>     MapType
%type<ttype>     SetType
%type<ttype>     ListType

%type<tdoc>      Definition
%type<ttype>     TypeDefinition

%type<ttypedef>  Typedef

%type<ttype>     TypeAnnotations
%type<ttype>     TypeAnnotationList
%type<tannot>    TypeAnnotation

%type<tfield>    Field
%type<tfieldid>  FieldIdentifier
%type<ereq>      FieldRequiredness
%type<ttype>     FieldType
%type<tconstv>   FieldValue
%type<tstruct>   FieldList

%type<tenum>     Enum
%type<tenum>     EnumDefList
%type<tenumv>    EnumDef

%type<ttypedef>  Senum
%type<tbase>     SenumDefList
%type<id>        SenumDef

%type<tconst>    Const
%type<tconstv>   ConstValue
%type<tconstv>   ConstList
%type<tconstv>   ConstListContents
%type<tconstv>   ConstMap
%type<tconstv>   ConstMapContents

%type<iconst>    StructHead
%type<tstruct>   Struct
%type<tstruct>   Xception
%type<tservice>  Service

%type<tfunction> Function
%type<ttype>     FunctionType
%type<tservice>  FunctionList

%type<tstruct>   Throws
%type<tservice>  Extends
%type<tbool>     Oneway
%type<tbool>     XsdAll
%type<tbool>     XsdOptional
%type<tbool>     XsdNillable
%type<tstruct>   XsdAttributes
%type<id>        CppType

%type<dtext>     CaptureDocText

%%

/**
 * Thrift Grammar Implementation.
 *
 * For the most part this source file works its way top down from what you
 * might expect to find in a typical .thrift file, i.e. type definitions and
 * namespaces up top followed by service definitions using those types.
 */

Program:
  HeaderList DefinitionList
    {
      C.pdebug("Program . Headers DefinitionList");
      /*
      TODO(dreiss): Decide whether full-program doctext is worth the trouble.
      if ($1 != null) {
        C.g_program.setDoc($1);
      }
      */
      C.clear_doctext();
    }

CaptureDocText:
    {
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        $$ = C.g_doctext;
        C.g_doctext = null;
      } else {
        $$ = null;
      }
    }

/* TODO(dreiss): Try to DestroyDocText in all sorts or random places. */
DestroyDocText:
    {
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.clear_doctext();
      }
    }

/* We have to DestroyDocText here, otherwise it catches the doctext
   on the first real element. */
HeaderList:
  HeaderList DestroyDocText Header
    {
      C.pdebug("HeaderList . HeaderList Header");
    }
|
    {
      C.pdebug("HeaderList . ");
    }

Header:
  Include
    {
      C.pdebug("Header . Include");
    }
| tok_namespace tok_identifier tok_identifier
    {
      C.pdebug("Header . tok_namespace tok_identifier tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace($2, $3);
      }
    }
| tok_namespace '*' tok_identifier
    {
      C.pdebug("Header . tok_namespace * tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("*", $3);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_cpp_namespace tok_identifier
    {
      C.pwarning(1, "'cpp_namespace' is deprecated. Use 'namespace cpp' instead");
      C.pdebug("Header . tok_cpp_namespace tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("cpp", $2);
      }
    }
| tok_cpp_include tok_literal
    {
      C.pdebug("Header . tok_cpp_include tok_literal");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addCppInclude($2);
      }
    }
| tok_php_namespace tok_identifier
    {
      C.pwarning(1, "'php_namespace' is deprecated. Use 'namespace php' instead");
      C.pdebug("Header . tok_php_namespace tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("php", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_py_module tok_identifier
    {
      C.pwarning(1, "'py_module' is deprecated. Use 'namespace py' instead");
      C.pdebug("Header . tok_py_module tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("py", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_perl_package tok_identifier
    {
      C.pwarning(1, "'perl_package' is deprecated. Use 'namespace perl' instead");
      C.pdebug("Header . tok_perl_namespace tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("perl", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_ruby_namespace tok_identifier
    {
      C.pwarning(1, "'ruby_namespace' is deprecated. Use 'namespace rb' instead");
      C.pdebug("Header . tok_ruby_namespace tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("rb", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_smalltalk_category tok_st_identifier
    {
      C.pwarning(1, "'smalltalk_category' is deprecated. Use 'namespace smalltalk.category' instead");
      C.pdebug("Header . tok_smalltalk_category tok_st_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("smalltalk.category", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_smalltalk_prefix tok_identifier
    {
      C.pwarning(1, "'smalltalk_prefix' is deprecated. Use 'namespace smalltalk.prefix' instead");
      C.pdebug("Header . tok_smalltalk_prefix tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("smalltalk.prefix", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_java_package tok_identifier
    {
      C.pwarning(1, "'java_package' is deprecated. Use 'namespace java' instead");
      C.pdebug("Header . tok_java_package tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("java", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_cocoa_prefix tok_identifier
    {
      C.pwarning(1, "'cocoa_prefix' is deprecated. Use 'namespace cocoa' instead");
      C.pdebug("Header . tok_cocoa_prefix tok_identifier");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("cocoa", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_xsd_namespace tok_literal
    {
      C.pwarning(1, "'xsd_namespace' is deprecated. Use 'namespace xsd' instead");
      C.pdebug("Header . tok_xsd_namespace tok_literal");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.setNamespace("cocoa", $2);
      }
    }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_csharp_namespace tok_identifier
   {
     C.pwarning(1, "'csharp_namespace' is deprecated. Use 'namespace csharp' instead");
     C.pdebug("Header . tok_csharp_namespace tok_identifier");
     if (C.g_parse_mode == C.ParseMode.PROGRAM) {
       C.g_program.setNamespace("csharp", $2);
     }
   }
/* TODO(dreiss): Get rid of this once everyone is using the new hotness. */
| tok_delphi_namespace tok_identifier
   {
     C.pwarning(1, "'delphi_namespace' is deprecated. Use 'namespace delphi' instead");
     C.pdebug("Header . tok_delphi_namespace tok_identifier");
     if (C.g_parse_mode == C.ParseMode.PROGRAM) {
       C.g_program.setNamespace("delphi", $2);
     }
   }

Include:
  tok_include tok_literal
    {
      C.pdebug("Include . tok_include tok_literal");
      if (C.g_parse_mode == C.ParseMode.INCLUDES) {
        String path = include_file(new String($2));
        if (!path.empty()) {
          C.g_program.addInclude(path, new String($2));
        }
      }
    }

DefinitionList:
  DefinitionList CaptureDocText Definition
    {
      C.pdebug("DefinitionList . DefinitionList Definition");
      if ($2 != null && $3 != null) {
        $3.setDoc($2);
      }
    }
|
    {
      C.pdebug("DefinitionList . ");
    }

Definition:
  Const
    {
      C.pdebug("Definition . Const");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addConst($1);
      }
      $$ = $1;
    }
| TypeDefinition
    {
      C.pdebug("Definition . TypeDefinition");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        g_scope.addType($1.getName(), $1);
        if (C.g_parent_scope != null) {
          g_parent_scope.addType(C.g_parent_prefix + $1.getName(), $1);
        }
      }
      $$ = $1;
    }
| Service
    {
      C.pdebug("Definition . Service");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_scope.addService($1.getName(), $1);
        if (C.g_parent_scope != null) {
          C.g_parent_scope.addService(C.g_parent_prefix + $1.getName(), $1);
        }
        C.g_program.addService($1);
      }
      $$ = $1;
    }

TypeDefinition:
  Typedef
    {
      C.pdebug("TypeDefinition . Typedef");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addTypedef($1);
      }
    }
| Enum
    {
      C.pdebug("TypeDefinition . Enum");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addEnum($1);
      }
    }
| Senum
    {
      C.pdebug("TypeDefinition . Senum");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addTypedef($1);
      }
    }
| Struct
    {
      C.pdebug("TypeDefinition . Struct");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addStruct($1);
      }
    }
| Xception
    {
      C.pdebug("TypeDefinition . Xception");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        C.g_program.addXception($1);
      }
    }

Typedef:
  tok_typedef FieldType tok_identifier
    {
      C.pdebug("TypeDef . tok_typedef FieldType tok_identifier");
      TTypedef *td = new TTypedef(C.g_program, $2, $3);
      $$ = td;
    }

CommaOrSemicolonOptional:
  ','
    {}
| ';'
    {}
|
    {}

Enum:
  tok_enum tok_identifier '{' EnumDefList '}'
    {
      C.pdebug("Enum . tok_enum tok_identifier { EnumDefList }");
      $$ = $4;
      $$.setName($2);
      $$.resolveValues();
      // make constants for all the enum values
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        List<TEnumValue> enum_values = $$.getConstants();
        for (TEnumValue value : enum_values) {
          String const_name = $$.getName() + "." + value.getName();
          TConstValue const_val = new TConstValue(value.getValue());
          const_val.seTEnum($$);
          g_scope.addConstant(const_name, new TConstValue(C.g_type_i32, value.getName(), const_val));
          if (C.g_parent_scope != null) {
            g_parent_scope.addConstant(C.g_parent_prefix + const_name, new TConst(C.g_type_i32, value.getName(), const_val));
          }
        }
      }
    }

EnumDefList:
  EnumDefList EnumDef
    {
      C.pdebug("EnumDefList . EnumDefList EnumDef");
      $$ = $1;
      $$.append($2);
    }
|
    {
      C.pdebug("EnumDefList . ");
      $$ = new TEnum(C.g_program);
    }

EnumDef:
  CaptureDocText tok_identifier '=' tok_int_constant CommaOrSemicolonOptional
    {
      C.pdebug("EnumDef . tok_identifier = tok_int_constant");
      if ($4 < 0) {
        C.pwarning(1, "Negative value supplied for enum "+$2+".\n");
      }
      if ($4 > INT_MAX) {
        C.pwarning(1, "64-bit value supplied for enum "+$2+".\n");
      }
      $$ = new TEnumValue($2, $4);
      if ($1 != null) {
        $$.setDoc($1);
      }
    }
|
  CaptureDocText tok_identifier CommaOrSemicolonOptional
    {
      C.pdebug("EnumDef . tok_identifier");
      $$ = new TEnumValue($2);
      if ($1 != null) {
        $$.setDoc($1);
      }
    }

Senum:
  tok_senum tok_identifier '{' SenumDefList '}'
    {
      C.pdebug("Senum . tok_senum tok_identifier { SenumDefList }");
      $$ = new TTypedef(C.g_program, $4, $2);
    }

SenumDefList:
  SenumDefList SenumDef
    {
      C.pdebug("SenumDefList . SenumDefList SenumDef");
      $$ = $1;
      $$.addStringEnumVal($2);
    }
|
    {
      C.pdebug("SenumDefList . ");
      $$ = new TBaseType("string", TBaseType.TYPE_STRING);
      $$.setStringEnum(true);
    }

SenumDef:
  tok_literal CommaOrSemicolonOptional
    {
      C.pdebug("SenumDef . tok_literal");
      $$ = $1;
    }

Const:
  tok_const FieldType tok_identifier '=' ConstValue CommaOrSemicolonOptional
    {
      C.pdebug("Const . tok_const FieldType tok_identifier = ConstValue");
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        g_scope.resolve_const_value($5, $2);
        $$ = new TConst($2, $3, $5);
        validate_const_type($$);

        g_scope.addConstant($3, $$);
        if (C.g_parent_scope != null) {
          g_parent_scope.addConstant(C.g_parent_prefix + $3, $$);
        }
      } else {
        $$ = null;
      }
    }

ConstValue:
  tok_int_constant
    {
      C.pdebug("ConstValue => tok_int_constant");
      $$ = new TConstValue();
      $$.setInteger($1);
      if (!g_allow_64bit_consts && ($1 < Integer.MIN_VALUE || $1 > Integer.MAX_VALUE)) {
        C.pwarning(1, "64-bit constant may not work in all languages.\n"+$1);
      }
    }
| tok_dub_constant
    {
      C.pdebug("ConstValue => tok_dub_constant");
      $$ = new TConstValue();
      $$.setDouble($1);
    }
| tok_literal
    {
      C.pdebug("ConstValue => tok_literal");
      $$ = new TConstValue($1);
    }
| tok_identifier
    {
      C.pdebug("ConstValue => tok_identifier");
      $$ = new TConstValue();
      $$.setIdentifier($1);
    }
| ConstList
    {
      C.pdebug("ConstValue => ConstList");
      $$ = $1;
    }
| ConstMap
    {
      C.pdebug("ConstValue => ConstMap");
      $$ = $1;
    }

ConstList:
  '[' ConstListContents ']'
    {
      C.pdebug("ConstList => [ ConstListContents ]");
      $$ = $2;
    }

ConstListContents:
  ConstListContents ConstValue CommaOrSemicolonOptional
    {
      C.pdebug("ConstListContents => ConstListContents ConstValue CommaOrSemicolonOptional");
      $$ = $1;
      $$.addList($2);
    }
|
    {
      C.pdebug("ConstListContents =>");
      $$ = new TConstValue();
      $$.setList();
    }

ConstMap:
  '{' ConstMapContents '}'
    {
      C.pdebug("ConstMap => { ConstMapContents }");
      $$ = $2;
    }

ConstMapContents:
  ConstMapContents ConstValue ':' ConstValue CommaOrSemicolonOptional
    {
      C.pdebug("ConstMapContents => ConstMapContents ConstValue CommaOrSemicolonOptional");
      $$ = $1;
      $$.addMap($2, $4);
    }
|
    {
      C.pdebug("ConstMapContents =>");
      $$ = new TConstValue();
      $$.seTMap();
    }

StructHead:
  tok_struct
    {
      $$ = C.struct_is_struct;
    }
| tok_union
    {
      $$ = C.struct_is_union;
    }

Struct:
  StructHead tok_identifier XsdAll '{' FieldList '}' TypeAnnotations
    {
      C.pdebug("Struct . tok_struct tok_identifier { FieldList }");
      $5.setXsdAll($3);
      $5.setUnion($1 == C.struct_is_union);
      $$ = $5;
      $$.setName($2);
      if ($7 != null) {
        $$.annotations.addAll($7.annotations);
      }
    }
    
XsdAll:
  tok_xsd_all
    {
      $$ = true;
    }
|
    {
      $$ = false;
    }

XsdOptional:
  tok_xsd_optional
    {
      $$ = true;
    }
|
    {
      $$ = false;
    }

XsdNillable:
  tok_xsd_nillable
    {
      $$ = true;
    }
|
    {
      $$ = false;
    }

XsdAttributes:
  tok_xsd_attrs '{' FieldList '}'
    {
      $$ = $3;
    }
|
    {
      $$ = null;
    }

Xception:
  tok_xception tok_identifier '{' FieldList '}'
    {
      C.pdebug("Xception . tok_xception tok_identifier { FieldList }");
      $4.setName($2);
      $4.setXception(true);
      $$ = $4;
    }

Service:
  tok_service tok_identifier Extends '{' FlagArgs FunctionList UnflagArgs '}'
    {
      C.pdebug("Service . tok_service tok_identifier { FunctionList }");
      $$ = $6;
      $$.setName($2);
      $$.setExtends($3);
    }

FlagArgs:
    {
       C.g_arglist = 1;
    }

UnflagArgs:
    {
       C.g_arglist = 0;
    }

Extends:
  tok_extends tok_identifier
    {
      C.pdebug("Extends . tok_extends tok_identifier");
      $$ = null;
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        $$ = g_scope.geTService($2);
        if ($$ == null) {
          yyerror("Service \"%s\" has not been defined.", $2);
          exit(1);
        }
      }
    }
|
    {
      $$ = null;
    }

FunctionList:
  FunctionList Function
    {
      C.pdebug("FunctionList . FunctionList Function");
      $$ = $1;
      $1.addFunction($2);
    }
|
    {
      C.pdebug("FunctionList . ");
      $$ = new TService(C.g_program);
    }

Function:
  CaptureDocText Oneway FunctionType tok_identifier '(' FieldList ')' Throws CommaOrSemicolonOptional
    {
      $6.setName(new String($4) + "_args");
      $$ = new TFunction($3, $4, $6, $8, $2);
      if ($1 != null) {
        $$.setDoc($1);
      }
    }

Oneway:
  tok_oneway
    {
      $$ = true;
    }
|
    {
      $$ = false;
    }

Throws:
  tok_throws '(' FieldList ')'
    {
      C.pdebug("Throws . tok_throws ( FieldList )");
      $$ = $3;
      if (C.g_parse_mode == C.ParseMode.PROGRAM && !validate_throws($$)) {
        yyerror("Throws clause may not contain non-exception types");
        exit(1);
      }
    }
|
    {
      $$ = new TStruct(C.g_program);
    }

FieldList:
  FieldList Field
    {
      C.pdebug("FieldList . FieldList , Field");
      $$ = $1;
      if (!($$.append($2))) {
        yyerror("Field identifier %d for \"%s\" has already been used", $2.getKey(), $2.getName());
        exit(1);
      }
    }
|
    {
      C.pdebug("FieldList . ");
      C.y_field_val = -1;
      $$ = new TStruct(C.g_program);
    }

Field:
  CaptureDocText FieldIdentifier FieldRequiredness FieldType tok_identifier FieldValue XsdOptional XsdNillable XsdAttributes TypeAnnotations CommaOrSemicolonOptional
    {
      C.pdebug("tok_int_constant : Field . FieldType tok_identifier");
      if ($2.auto_assigned) {
        C.pwarning(1, "No field key specified for "+$5+", resulting protocol may have conflicts or not be backwards compatible!\n");
        if (C.g_strict >= 192) {
          yyerror("Implicit field keys are deprecated and not allowed with -strict");
          exit(1);
        }
      }
      $$ = new TField($4, $5, $2.value);
      $$.setReq($3);
      if ($6 != null) {
        g_scope.resolveConstValue($6, $4);
        C.validateFieldValue($$, $6);
        $$.setValue($6);
      }
      $$.setXsdOptional($7);
      $$.setXsdNillable($8);
      if ($1 != null) {
        $$.setDoc($1);
      }
      if ($9 != null) {
        $$.setXsdAttrs($9);
      }
      if ($10 != null) {
        $$.annotations.addAll($10.annotations);
      }
    }

FieldIdentifier:
  tok_int_constant ':'
    {
      if ($1 <= 0) {
        if (C.g_allow_neg_field_keys) {
          /*
           * g_allow_neg_field_keys exists to allow users to add explicitly
           * specified key values to old .thrift files without breaking
           * protocol compatibility.
           */
          if ($1 != C.y_field_val) {
            /*
             * warn if the user-specified negative value isn't what
             * thrift would have auto-assigned.
             */
            C.pwarning(1, "Negative field key ("+$1+") differs from what would be "+
                     "auto-assigned by thrift ("+C.y_field_val+").\n");
          }
          /*
           * Leave $1 as-is, and update y_field_val to be one less than $1.
           * The FieldList parsing will catch any duplicate key values.
           */
          C.y_field_val = $1 - 1;
          $$.value = $1;
          $$.autoAssigned = false;
        } else {
          C.pwarning(1, "Nonpositive value ("+$1+") not allowed as a field key.\n");
          $$.value = C.y_field_val--;
          $$.auto_assigned = true;
        }
      } else {
        $$.value = $1;
        $$.auto_assigned = false;
      }
    }
|
    {
      $$.value = C.y_field_val--;
      $$.auto_assigned = true;
    }

FieldRequiredness:
  tok_required
    {
      $$ = TField.T_REQUIRED;
    }
| tok_optional
    {
      if (C.g_arglist) {
        if (C.g_parse_mode == C.ParseMode.PROGRAM) {
          C.pwarning(1, "optional keyword is ignored in argument lists.\n");
        }
        $$ = TField.T_OPT_IN_REQ_OUT;
      } else {
        $$ = TField.T_OPTIONAL;
      }
    }
|
    {
      $$ = TField.T_OPT_IN_REQ_OUT;
    }

FieldValue:
  '=' ConstValue
    {
      if (C.g_parse_mode == C.ParseMode.PROGRAM) {
        $$ = $2;
      } else {
        $$ = null;
      }
    }
|
    {
      $$ = null;
    }

FunctionType:
  FieldType
    {
      C.pdebug("FunctionType . FieldType");
      $$ = $1;
    }
| tok_void
    {
      C.pdebug("FunctionType . tok_void");
      $$ = g_type_void;
    }

FieldType:
  tok_identifier
    {
      C.pdebug("FieldType . tok_identifier");
      if (C.g_parse_mode == C.ParseMode.INCLUDES) {
        // Ignore identifiers in include mode
        $$ = null;
      } else {
        // Lookup the identifier in the current scope
        $$ = g_scope.getType($1);
        if ($$ == null) {
          yyerror("Type \"%s\" has not been defined.", $1);
          exit(1);
        }
      }
    }
| BaseType
    {
      C.pdebug("FieldType . BaseType");
      $$ = $1;
    }
| ContainerType
    {
      C.pdebug("FieldType . ContainerType");
      $$ = $1;
    }

BaseType: SimpleBaseType TypeAnnotations
    {
      C.pdebug("BaseType . SimpleBaseType TypeAnnotations");
      if ($2 != null) {
        $$ = new TBaseType((TBaseType)($1));
        $$.annotations_ = $2.annotations_;
        delete $2;
      } else {
        $$ = $1;
      }
    }

SimpleBaseType:
  tok_string
    {
      C.pdebug("BaseType . tok_string");
      $$ = g_type_string;
    }
| tok_binary
    {
      C.pdebug("BaseType . tok_binary");
      $$ = g_type_binary;
    }
| tok_slist
    {
      C.pdebug("BaseType . tok_slist");
      $$ = g_type_slist;
    }
| tok_bool
    {
      C.pdebug("BaseType . tok_bool");
      $$ = g_type_bool;
    }
| tok_byte
    {
      C.pdebug("BaseType . tok_byte");
      $$ = g_type_byte;
    }
| tok_i16
    {
      C.pdebug("BaseType . tok_i16");
      $$ = g_type_i16;
    }
| tok_i32
    {
      C.pdebug("BaseType . tok_i32");
      $$ = g_type_i32;
    }
| tok_i64
    {
      C.pdebug("BaseType . tok_i64");
      $$ = g_type_i64;
    }
| tok_double
    {
      C.pdebug("BaseType . tok_double");
      $$ = g_type_double;
    }

ContainerType: SimpleContainerType TypeAnnotations
    {
      C.pdebug("ContainerType . SimpleContainerType TypeAnnotations");
      $$ = $1;
      if ($2 != null) {
        $$.annotations.addAll($2.annotations);
        delete $2;
      }
    }

SimpleContainerType:
  MapType
    {
      C.pdebug("SimpleContainerType . MapType");
      $$ = $1;
    }
| SetType
    {
      C.pdebug("SimpleContainerType . SetType");
      $$ = $1;
    }
| ListType
    {
      C.pdebug("SimpleContainerType . ListType");
      $$ = $1;
    }

MapType:
  tok_map CppType '<' FieldType ',' FieldType '>'
    {
      C.pdebug("MapType . tok_map <FieldType, FieldType>");
      $$ = new TMap($4, $6);
      if ($2 != null) {
        ((TContainer)$$).setCppName(new String($2));
      }
    }

SetType:
  tok_set CppType '<' FieldType '>'
    {
      C.pdebug("SetType . tok_set<FieldType>");
      $$ = new TSet($4);
      if ($2 != null) {
        ((TContainer)$$).setCppName(new String($2));
      }
    }

ListType:
  tok_list '<' FieldType '>' CppType
    {
      C.pdebug("ListType . tok_list<FieldType>");
      $$ = new TList($3);
      if ($5 != null) {
        ((TContainer)$$).setCppName(new String($5));
      }
    }

CppType:
  tok_cpp_type tok_literal
    {
      $$ = $2;
    }
|
    {
      $$ = null;
    }

TypeAnnotations:
  '(' TypeAnnotationList ')'
    {
      C.pdebug("TypeAnnotations . ( TypeAnnotationList )");
      $$ = $2;
    }
|
    {
      $$ = null;
    }

TypeAnnotationList:
  TypeAnnotationList TypeAnnotation
    {
      C.pdebug("TypeAnnotationList . TypeAnnotationList , TypeAnnotation");
      $$ = $1;
      $$.annotations.put($2.key, $2.val);
      delete $2;
    }
|
    {
      /* Just use a dummy structure to hold the annotations. */
      $$ = new TStruct(C.g_program);
    }

TypeAnnotation:
  tok_identifier '=' tok_literal CommaOrSemicolonOptional
    {
      C.pdebug("TypeAnnotation . tok_identifier = tok_literal");
      $$ = new TAnnotation();
      $$.key = $1;
      $$.val = $3;
    }

%%

